Рассмотрим язык, чуть более похожий на Си, чем в прошлый раз.
В нём есть следующие простые типы:

\vspace*{1em}
\begin{tabular}{|l|l|l|}
Имя типа & Размер \\ \hline
\t{bool} & 1 байт \\
\t{char} или \t{signed char} & 1 байт \\
\t{unsigned char} & 1 байт \\
\t{short}, \t{signed short}, \t{short int} или \t{signed short int} & 2 байта \\
\t{unsigned short} или \t{unsigned short int} & 2 байта \\
\t{int}, \t{signed} или \t{signed int} & 4 байта \\
\t{unsigned} или \t{unsigned int} & 4 байта \\
\t{long}, \t{signed long}, \t{long int} или \t{signed long int} & 8 байт \\
\t{unsigned long} или \t{unsigned long int} & 8 байт \\
\t{long long}, \t{signed long long}, \t{long long int} или \t{signed long long int} & 8 байт \\
\t{unsigned long long} или \t{unsigned long long int} & 8 байт \\
\end{tabular}
\vspace*{1em}

В языке есть оператор \t{sizeof}, который позволяет узнать размер любого типа в байтах.
К примеру, \t{sizeof(int)} равен четырём.

В языке есть оператор \t{alignof}, который позволяет узнать {\bf выравнивание} любого типа в байтах.
Адрес переменной какого-то типа \t{T} в памяти должен делиться на \t{alignof(T)}.
\t{sizeof(T)} всегда делится на \t{alignof(T)}.
\t{alignof(T)} всегда является неотрицательной целой степенью двойки.
Для простых типов, \t{alignof(T) == sizeof(T)}. 

В языке есть массивы фиксированной длины, состоящие из элементов одного типа.
Массив из \t{n} элементов, каждый типа \t{T} обозначается как \t{T[n]}.
\t{sizeof(T[n])} равен \t{sizeof(T) * n}. К примеру, \t{sizeof(short[13])} равен 26,
так как размер типа \t{short}~--- два байта, а в массиве 13 элементов.
\t{alignof(T[n])} равен \t{alignof(T)}. Поддержки многомерных массивов в языке нет.

В языке есть структуры~--- композитные типы, позволяющие объединять фиксированное количество переменных (полей) разных типов в одну.
Пусть в структуре $n > 0$ полей $f_1, \ldots, f_n$ типов $T_1, \ldots, T_n$.
Пусть эта структура лежит в памяти по адресу $a$.
Тогда должны выполняться следующие дополнительные условия:

\begin{itemize}
 \item Адрес $f_1$ равен $a$.
 \item Для $k = 2, \ldots, n$, Адрес $f_k$ больше адреса $f_{k-1}$.
 \item Поля не могут пересекаться
 \item
Как и для самой структуры, так и для всех её полей должны выполнятся стандартные правила выравнивания.
 \item Выравнивание структуры~--- максимум из выравниваний её полей.
 \item Размер структуры не меньше суммы размеров её полей.
 \item Размер структуры~--- минимальный из размеров, удовлетворяющий всем условиям.
\end{itemize}

Вам предлагается написать программу, вычисляющую \t{sizeof} и \t{alignof} для произвольных типов.

\InputFile

Во входном файле записаны команды, \t{typedef}, \t{sizeof} или \t{alignof}.

Команда \t{typedef} объявляет новый тип. Например, \t{typedef eightbytes unsigned char[8]} объявляет новый тип \t{eightbytes}, который представляет собой массив из восьми \t{unsigned char}. \t{typedef} может также объявлять структуры. Смотрите примеры.
Гарантируется, что имя нового типа~--- непустая строка из латинских букв длиной не более 32 символов, кроме
\t{bool}, \t{char}, \t{signed}, \t{unsigned}, \t{short}, \t{int}, \t{long}, \t{struct},
\t{typedef}, \t{sizeof}, \t{alignof}

Гарантируется, что объявления новых типов имеют уникальные имена.

Команды \t{sizeof} и \t{alignof} печатают на экран на новой строке размер и выравнивание типа соответственно. Например, \t{sizeof unsigned char[8]} напечатает на экран \t{8}.

Гарантируется, что размер входных данных по объёму не превосходит одного мегабайта. Размер каждого используемого типа не превосходит одного эксабайта.

\OutputFile

Для каждой команды \t{sizeof} или \t{alignof} в отдельной строке напечатайте результат выполнения соответствующего оператора.

\SAMPLES
